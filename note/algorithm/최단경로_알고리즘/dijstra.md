# λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦
- μ—¬λ¬ κ°μ λ…Έλ“κ°€ μμ„ λ• νΉμ •ν• λ…Έλ“μ—μ„ μ¶λ°ν•μ—¬ λ‹¤λ¥Έ λ…Έλ“λ΅ κ°€λ” κ°κ°μ μµλ‹¨ κ²½λ΅λ¥Ό κµ¬ν•λ” μ•κ³ λ¦¬μ¦
    - κΈ°λ³Έμ μΌλ΅ κ·Έλ¦¬λ””
    - λ§¤λ² **κ°€μ¥ λΉ„μ©μ΄ μ μ€ λ…Έλ“** μ„ νƒ
    - κ° λ…Έλ“μ— λ€ν• ν„μ¬κΉμ§€μ μµλ‹¨ κ±°λ¦¬ μ •λ³΄λ¥Ό ν•­μƒ 1μ°¨μ› λ¦¬μ¤νΈ(μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”)μ— μ €μ¥ν•λ©° λ¦¬μ¤νΈλ¥Ό κ³„μ† κ°±μ‹ ν•¨
- μμ κ°„μ„ (0λ³΄λ‹¤ μ‘μ€ κ°’μ„ κ°–λ” κ°„μ„ )μ΄ μ—†μ„ λ• μ •μƒ μ‘λ™ν•¨
- GPS μ†ν”„νΈμ›¨μ–΄μ κΈ°λ³Έ μ•κ³ λ¦¬μ¦

## μ „μ²΄ νλ¦„
1. μ¶λ° λ…Έλ“λ¥Ό μ„ νƒν•¨
2. μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ„ μ΄κΈ°ν™”ν•¨
3. λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“ μ¤‘μ—μ„ μµλ‹¨ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“λ¥Ό μ„ νƒν•¨
4. ν•΄λ‹Ή λ…Έλ“λ¥Ό κ±°μ³ λ‹¤λ¥Έ λ…Έλ“λ΅ κ°€λ” λΉ„μ©μ„ κ³„μ‚°ν•μ—¬ μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ„ κ°±μ‹ ν•¨ (κ·Έλ¦¬λ””)
5. μ„ κ³Όμ •μ—μ„ 3λ²κ³Ό 4λ²μ„ λ°λ³µν•¨
    - λ‹¤μ λ…Έλ“λ¥Ό κ³ λ¥Ό λ•λ” λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“ μ¤‘μ—μ„ μµλ‹¨ κ±°λ¦¬κ°€ μ§§μ€ κ²ƒ μ„ νƒ
    - μµλ‹¨ κ±°λ¦¬κ°€ κ°™μΌλ©΄ λ²νΈκ°€ μ‘μ€ κ²ƒ
- ν• λ² μ„ νƒλ λ…Έλ“λ” μµλ‹¨ κ±°λ¦¬κ°€ κ°μ†ν•μ§€ μ•λ”λ‹¤
- ν• λ‹¨κ³„λ‹Ή ν•λ‚μ λ…Έλ“μ— λ€ν• μµλ‹¨ κ±°λ¦¬λ¥Ό ν™•μ‹¤ν μ°Ύλ” κ²ƒ
- λ§μ§€λ§‰ λ…Έλ“μ— λ€ν•΄μ„λ” ν•΄λ‹Ή λ…Έλ“λ¥Ό κ±°μ³ λ‹¤λ¥Έ λ…Έλ“λ΅ κ°€λ” κ²½μ°λ¥Ό ν™•μΈν•  ν•„μ”κ°€ μ—†μ
    - λ‚λ¨Έμ§€ λ…Έλ“μ— λ€ν• μµλ‹¨ κ±°λ¦¬κ°€ ν™•μ •λ μƒνƒμ΄λ―€λ΅ λ” μ΄μƒ ν…μ΄λΈ”μ΄ κ°±μ‹ λ  μ μ—†μ

## κµ¬ν„ 1(μ‰½μ§€λ§ λλ¦Ό)
- o(V^2)μ μ‹κ°„λ³µμ΅λ„
    - Vλ” λ…Έλ“μ κ°―μ
- λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“ μ¤‘μ—μ„ μµλ‹¨ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“λ¥Ό μ„ νƒν•κΈ° μ„ν•΄ λ§¤ λ‹¨κ³„λ§λ‹¤ 1μ°¨μ› λ¦¬μ¤νΈμ λ¨λ“  μ›μ†λ¥Ό ν™•μΈ(μμ°¨ νƒμƒ‰)ν•¨
- λ…Έλ“ κ°μκ°€ 5,000κ° μ΄ν•λ©΄ κ°€λ¥
- λ…Έλ“ κ°μκ°€ 10,000κ° λ„μ–΄κ°€λ©΄ λ¶κ°€λ¥
```python
import sys
input = sys.stdin.readline
INF = int(1e9) # λ¬΄ν•μ„ μλ―Έν•λ” κ°’μΌλ΅ 10μ–µμ„ μ„¤μ •

# λ…Έλ“μ κ°μ, κ°„μ„ μ κ°μλ¥Ό μ…λ ¥λ°›κΈ°
n,m = map(int, input().split())
# μ‹μ‘ λ…Έλ“ λ²νΈλ¥Ό μΈλ ¥λ°›κΈ°
start = int(input())
# κ° λ…Έλ“μ— μ—°κ²°λμ–΄ μλ” λ…Έλ“μ— λ€ν• μ •λ³΄λ¥Ό λ‹΄λ” λ¦¬μ¤νΈλ¥Ό λ§λ“¤κΈ°
graph = [[] for i in range(n+1)]
# λ°©λ¬Έν• μ μ΄ μλ”μ§€ μ²΄ν¬ν•λ” λ©μ μ λ¦¬μ¤νΈ λ§λ“¤κΈ°
visited = [False] * (n+1)
# μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ„ λ¨λ‘ λ¬΄ν•μΌλ΅ μ΄κΈ°ν™”
distance = [INF] * (n+1)

# λ¨λ“  κ°„μ„  μ •λ³΄λ¥Ό μ…λ ¥λ°›κΈ°
for _ in range(m):
    a,b,c = map(int, input().split())
    # aλ² λ…Έλ“μ—μ„ bλ΅ κ°€λ” λΉ„μ©μ΄ cμ„
    graph[a].append((b,c))

def get_smallest_node():
    min_value = INF
    index = 0 # κ°€μ¥ μµλ‹¨ κ±°λ¦¬κ°€ μ§§μ€ λ…Έλ“(μΈλ±μ¤)
    for i in range(1,n+1):
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            index = i
    return index

def dijstra(start):
    # μ‹μ‘ λ…Έλ“μ— λ€ν•΄μ„ μ΄κΈ°ν™”
    distance[start] = 0
    visited[start] = True
    for j in graph[start]:
        distance[j[0]] = j[1]
    # μ‹μ‘ λ…Έλ“λ¥Ό μ μ™Έν• μ „μ²΄ n-1κ°μ λ…Έλ“μ— λ€ν•΄ λ°λ³µ
    for i in range(n-1):
        # ν„μ¬ μµλ‹¨ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“(λ‹¤μμ— κ° λ…Έλ“)λ¥Ό κΊΌλ‚΄μ„, λ°©λ¬Έ μ²λ¦¬
        now = get_smallest_node()
        visited[now] = True
        for j in graph[now]:
            cost = distance[now] + j[1]
            if cost < distance[j[0]]:
                distance[j[0]] = cost

# λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦ μν–‰
dijstra(start)

# λ¨λ“  λ…Έλ“λ΅ κ°€κΈ° μ„ν• μµλ‹¨ κ±°λ¦¬λ¥Ό μ¶λ ¥
for i in range(1,n+1):
    # λ„λ‹¬ν•  μ μ—†λ” κ²½μ°, λ¬΄ν• μ¶λ ¥
    if distance[i] == INF:
        print("INFINITY")
    # λ„λ‹¬ν•  μ μλ” κ²½μ° κ±°λ¦¬λ¥Ό μ¶λ ¥
    else:
        print(distance[i])
```

## κµ¬ν„ 2(κΉλ‹¤λ΅­μ§€λ§ λΉ λ¦„)
- o(ElogV)μ μ‹κ°„λ³µμ΅λ„
    - E : κ°„μ„ μ κ°μ
    - V : λ…Έλ“μ κ°μ
- μµλ‹¨ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“λ¥Ό μ„ ν•μ μΌλ΅ μ°Ύλ” κ²ƒμ΄ μ•„λ‹λΌλ©΄? => [ν™ μλ£κµ¬μ΅°](../dataStructure/prqueue_heap.md) μ‚¬μ© 
- μµλ‹¨ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“λ¥Ό μ„ νƒν•λ” κ³Όμ •μ„ λ‹¤μµμ¤νΈλΌ μµλ‹¨ κ²½λ΅ ν•¨μ μ•μ—μ„ μ°μ„ μμ„ νλ¥Ό μ΄μ©ν•λ” λ°©μ‹μΌλ΅ λ€μ²΄ν•¨

```python
import heapq
import sys
input = sys.stdin.readline
INF = int(1e9) # λ¬΄ν•μ„ μλ―Έν•λ” κ°’μΌλ΅ 10μ–µμ„ μ„¤μ •

# λ…Έλ“μ κ°μ, κ°„μ„ μ κ°μλ¥Ό μ…λ ¥λ°›κΈ°
n,m = map(int, input().split())
# μ‹μ‘ λ…Έλ“ λ²νΈλ¥Ό μΈλ ¥λ°›κΈ°
start = int(input())
# κ° λ…Έλ“μ— μ—°κ²°λμ–΄ μλ” λ…Έλ“μ— λ€ν• μ •λ³΄λ¥Ό λ‹΄λ” λ¦¬μ¤νΈλ¥Ό λ§λ“¤κΈ°
graph = [[] for i in range(n+1)]
# μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ„ λ¨λ‘ λ¬΄ν•μΌλ΅ μ΄κΈ°ν™”
distance = [INF] * (n+1)

# λ¨λ“  κ°„μ„  μ •λ³΄λ¥Ό μ…λ ¥λ°›κΈ°
for _ in range(m):
    a,b,c = map(int, input().split())
    # aλ² λ…Έλ“μ—μ„ bλ΅ κ°€λ” λΉ„μ©μ΄ cμ„
    graph[a].append((b,c))

def dijsktra(start):
    q = []
    # μ‹μ‘ λ…Έλ“λ΅ κ°€κΈ° μ„ν• μµλ‹¨ κ²½λ΅λ¥Ό 0μΌλ΅ μ„¤μ •ν•μ—¬, νμ— μ‚½μ…
    heapq.heappush(q, (0,start))
    distance[start] = 0
    while q: # νκ°€ λΉ„μ–΄μμ§€ μ•λ‹¤λ©΄
        # κ°€μ¥ μµλ‹¨ κ±°λ¦¬κ°€ μ§§μ€ λ…Έλ“μ— λ€ν• μ •λ³΄ κΊΌλ‚΄κΈ°
        dist, now = heapq.heappop(q)
        # ν„μ¬ λ…Έλ“κ°€ μ΄λ―Έ μ²λ¦¬λ μ μ΄ μλ” λ…Έλ“λΌλ©΄ λ¬΄μ‹
        if distance[now] < dist:
            continue
        # ν„μ¬ λ…Έλ“μ™€ μ—°κ²°λ λ‹¤λ¥Έ μΈμ ‘ν• λ…Έλ“λ“¤μ„ ν™•μΈ
        for i in graph[now]:
            cost = dist + i[1]
            # ν„μ¬ λ…Έλ“λ¥Ό κ±°μ³μ„, λ‹¤λ¥Έ λ…Έλ“λ΅ μ΄λ™ν•λ” κ±°λ¦¬κ°€ λ” μ§§μ€ κ²½μ°
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost,i[0]))

# λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦ μν–‰
dijsktra(start)

# λ¨λ“  λ…Έλ“λ΅ κ°€κΈ° μ„ν• μµλ‹¨ κ±°λ¦¬λ¥Ό μ¶λ ¥
for i in range(1,n+1):
    # λ„λ‹¬ν•  μ μ—†λ” κ²½μ°, λ¬΄ν• μ¶λ ¥
    if distance[i] == INF:
        print("INFINITY")
    # λ„λ‹¬ν•  μ μλ” κ²½μ° κ±°λ¦¬λ¥Ό μ¶λ ¥
    else:
        print(distance[i])
```
- whileλ¬Έμ€ λ…Έλ“μ κ°μ v μ΄μƒμ νμλ΅λ” λ°λ³µλμ§€ μ•μ

[π  λ©λ΅μΌλ΅](/README.md)